*** 1- Introduction ***
## Section Overview: Creating Layouts in React Native

This section focuses on building layouts in React Native and marks the start of implementing real application screens. You will apply these concepts directly when building the first two screens of the app.

---

## What You Will Learn

### 1. Layout Fundamentals

* How layouts work in React Native
* Differences between React Native layouts and web (CSS) layouts

### 2. Dimensions

* Working with screen width and height
* Using the `Dimensions` API
* Adapting layouts to different device sizes

### 3. Device Orientation

* Handling portrait and landscape modes
* Responding to orientation changes
* Designing responsive layouts across orientations

### 4. Flexbox in React Native

* Core flexbox concepts
* `flexDirection`, `justifyContent`, and `alignItems`
* Building flexible and adaptive UI layouts

### 5. Positioning

* Relative positioning (default behavior)
* Absolute positioning
* When and why to use each positioning method

---

## Practical Application

* You will use all these concepts to build:

  * The first screen of the app
  * The second screen of the app
* These topics are essential for completing the exercises at the end of this section

---

## Notes

* Pay close attention to each lesson
* Take notes as these concepts are foundational
* Expect to reuse these layout techniques throughout the course

---

## Section Goal

By the end of this section, you should feel comfortable creating responsive, well-structured layouts in React Native using flexbox, dimensions, orientation handling, and positioning techniques.


*** 2- Dimensions ***
---

## Component Dimensions in React Native

### 1. Using Fixed Dimensions with `View`

In React Native, we control the size of components using **density-independent pixels (DIPs)** rather than raw pixels.

#### Example Setup

We start by importing `View` and rendering it inside a `SafeAreaView`.

-------------------code----------------------
import React from "react";
import { SafeAreaView, View } from "react-native";

export default function App() {
  return (
    <SafeAreaView>
      <View
        style={{
          backgroundColor: "dodgerblue",
          width: 150,
          height: 70,
        }}
      />
    </SafeAreaView>
  );
}
-------------------code----------------------

* `width: 150` and `height: 70` are expressed in **density-independent pixels (DIPs)**.
* DIPs allow components to appear at nearly the same physical size across different devices.

---

### 2. What Are Density-Independent Pixels (DIPs)?

* DIPs are **abstract units**, not actual pixels.
* The real pixel size depends on the device’s **scale factor**.

#### Example: iPhone 4

* Screen size: `320 × 480` points
* Scale factor: `2x`
* Actual resolution: `640 × 960` pixels

If a view has:

-------------------code----------------------
width: 150
-------------------code----------------------

Actual pixel width:

-------------------code----------------------
150 × 2 = 300 pixels
-------------------code----------------------

This is roughly half the screen width.

#### Example: iPhone 11 Pro Max

* Screen size: `414 × 896` points
* Scale factor: `3x`

Actual pixel width:

-------------------code----------------------
150 × 3 = 450 pixels
-------------------code----------------------

Again, roughly half the screen width, though it may appear slightly smaller relative to the screen.

#### Key Takeaway

You do **not** need to memorize device sizes or scale factors.

By using DIPs, React Native ensures that components look almost the same size across different devices.

---

### 3. Using Percentage-Based Dimensions

If you want a component to take **exactly half of the screen width**, you can use percentage values.

-------------------code----------------------
<View
  style={{
    backgroundColor: "dodgerblue",
    width: "50%",
    height: 70,
  }}
/>
-------------------code----------------------

Important notes:

* Percentage values must be written as **strings**.
* This guarantees proportional sizing regardless of device width.

---

### 4. Getting Screen Dimensions with the `Dimensions` API

In some cases, you may need to adjust layout based on the actual screen size.

#### Importing `Dimensions`

-------------------code----------------------
import { Dimensions } from "react-native";
-------------------code----------------------

#### Accessing Screen Size

-------------------code----------------------
const screen = Dimensions.get("screen");
console.log(screen);
-------------------code----------------------

* The argument can be:

  * `"screen"`: total screen size
  * `"window"`: visible application window

#### Difference Between `screen` and `window`

* On **iOS**: `screen` and `window` are usually the same.
* On **Android**: `window` is slightly smaller due to system UI elements.

#### Example Output

-------------------code----------------------
{
  width: 414,
  height: 896,
  scale: 3,
  fontScale: 1
}
-------------------code----------------------

* `scale: 3` means each point equals 3 physical pixels.

---

### 5. Limitation of the `Dimensions` API

The `Dimensions` API **does not automatically update** when the device orientation changes.

* If the user rotates the device, the width and height values remain the same.
* Handling orientation changes requires additional APIs, which will be covered in the next lesson.

---

## Summary

* React Native uses **density-independent pixels (DIPs)** instead of raw pixels.
* DIPs help maintain consistent component sizing across devices.
* Use **percentages** when you need exact proportional sizing.
* Use the **Dimensions API** to read screen or window size.
* `Dimensions.get()` does **not** respond to orientation changes by default.

---


*** 3- Detecting Orientation Changes ***

---

## Detecting Screen Orientation in React Native

### 1. Why Screen Orientation Matters

Sometimes we need to resize components based on whether the device is in **portrait** or **landscape** mode.

#### Example Scenario: Video Player

* Width: `100%`
* Height:

  * `30%` in portrait mode
  * `100%` in landscape mode

In portrait mode, the video player appears at the top.
In landscape mode, it should take the entire screen.

Using a fixed percentage alone is not enough because it does not change when the device rotates.

---

### 2. Enabling Multiple Orientations

By default, React Native apps support **portrait mode only**.

#### Update `app.json`

-------------------code----------------------
{
  "expo": {
    "orientation": "default"
  }
}
-------------------code----------------------

Available values:

* `"portrait"`: portrait only (default)
* `"landscape"`: landscape only
* `"default"`: supports both portrait and landscape

To support orientation changes, we must use `"default"`.

---

### 3. Rotating the Simulator

* iOS Simulator (Mac): `Command + Left / Right Arrow`
* Android Emulator:

  * Use the rotation buttons in the toolbar
  * Keyboard shortcuts may differ by OS

---

### 4. Why the Built-in `Dimensions` API Is Not Enough

The `Dimensions` API from `react-native`:

* Does **not** update automatically when orientation changes
* Returns static values unless manually handled

To solve this, we use **React Native Community Hooks**.

---

### 5. Installing React Native Community Hooks

In the terminal:

-------------------code----------------------
npm install @react-native-community/hooks
-------------------code----------------------

This library provides hooks that automatically respond to changes such as:

* Screen dimensions
* Device orientation

---

### 6. Using `useDimensions` Hook

#### Importing the Hook

-------------------code----------------------
import { useDimensions } from "@react-native-community/hooks";
-------------------code----------------------

#### Using It in a Component

-------------------code----------------------
import React from "react";
import { SafeAreaView, View } from "react-native";
import { useDimensions } from "@react-native-community/hooks";

export default function App() {
  const { width, height } = useDimensions().screen;

  console.log(width, height);

  return (
    <SafeAreaView>
      <View
        style={{
          backgroundColor: "black",
          width: "100%",
          height: "30%",
        }}
      />
    </SafeAreaView>
  );
}
-------------------code----------------------

Key points:

* `useDimensions()` always returns **updated values**
* Width and height change automatically when the device rotates
* This is the preferred way to read screen size when supporting multiple orientations

---

### 7. Detecting Orientation with `useDeviceOrientation`

#### Importing the Hook

-------------------code----------------------
import { useDeviceOrientation } from "@react-native-community/hooks";
-------------------code----------------------

#### Using the Hook

-------------------code----------------------
const orientation = useDeviceOrientation();
console.log(orientation);
-------------------code----------------------

Returned object:

-------------------code----------------------
{
  portrait: true,
  landscape: false
}
-------------------code----------------------

When the device rotates, the values update automatically.

---

### 8. Dynamically Resizing a Component Based on Orientation

We can now combine `useDeviceOrientation` with conditional styling.

#### Example: Responsive Video Player

-------------------code----------------------
import React from "react";
import { SafeAreaView, View } from "react-native";
import { useDeviceOrientation } from "@react-native-community/hooks";

export default function App() {
  const { landscape } = useDeviceOrientation();

  return (
    <SafeAreaView>
      <View
        style={{
          backgroundColor: "black",
          width: "100%",
          height: landscape ? "100%" : "30%",
        }}
      />
    </SafeAreaView>
  );
}
-------------------code----------------------

Behavior:

* Portrait mode → height is `30%`
* Landscape mode → height is `100%`

This makes the component fully responsive to orientation changes.

---

### 9. Safe Area Consideration

When using `SafeAreaView`:

* The component may not cover the entire screen in landscape mode
* This creates empty edges on some devices

For elements like video players, it may be better **not** to wrap them in `SafeAreaView`.

This detail is outside the scope of this lesson.

---

### 10. Final Configuration for This Course

Since the app built in this course does **not** support landscape mode:

#### Reset `app.json`

-------------------code----------------------
{
  "expo": {
    "orientation": "portrait"
  }
}
-------------------code----------------------

---

## Summary

* Orientation-aware layouts require detecting screen rotation
* `Dimensions` API does not update on rotation
* `@react-native-community/hooks` provides:

  * `useDimensions` for responsive screen size
  * `useDeviceOrientation` for orientation detection
* Orientation-based styling enables dynamic layouts
* App orientation support is controlled via `app.json`

---

*** 4- Flexbox ***
---

## Flexbox in React Native — Organized Notes

### 1. What is Flex (Flexbox)

* Flexbox is a layout system used to build responsive and consistent layouts.
* React Native uses Flexbox by default.
* The concept is similar to CSS Flexbox, but there are **important differences**, so prior CSS knowledge is helpful but not enough.
* Flexbox helps layouts adapt to different screen sizes easily.

---

### 2. Basic Setup

We start by removing all previous code and importing only the `View` component.

-------------------code----------------------
import { View } from 'react-native';
-------------------code----------------------

---

### 3. Using `flex` to Fill the Screen

Inside the `App` component, return a single `View`.

-------------------code----------------------
export default function App() {
  return (
    <View style={{ backgroundColor: 'dodgerblue', flex: 1 }} />
  );
}
-------------------code----------------------

#### Explanation

* `flex: 1` means the view expands to take **all available free space**.
* This makes the view fill the entire screen.

---

### 4. Changing the Flex Value

If we change the flex value:

-------------------code----------------------
<View style={{ backgroundColor: 'dodgerblue', flex: 0.5 }} />
-------------------code----------------------

#### Result

* The view takes **half of the screen** instead of the full screen.

---

### 5. Flex as a Container

In most layouts:

* One `View` acts as a **container**
* Child views are aligned inside it

Let’s turn our main view into a container.

-------------------code----------------------
export default function App() {
  return (
    <View style={{ backgroundColor: 'white', flex: 1 }}>
      <View style={{ backgroundColor: 'dodgerblue', flex: 1 }} />
    </View>
  );
}
-------------------code----------------------

#### Explanation

* The white view fills the screen.
* The blue child view expands to fill the container.
* Result: the screen still looks fully blue because the child occupies all available space.

---

### 6. Multiple Child Views

Now we add more child views.

-------------------code----------------------
export default function App() {
  return (
    <View style={{ backgroundColor: 'white', flex: 1 }}>
      <View style={{ backgroundColor: 'dodgerblue', flex: 1 }} />
      <View style={{ backgroundColor: 'gold', flex: 1 }} />
      <View style={{ backgroundColor: 'tomato', flex: 1 }} />
    </View>
  );
}
-------------------code----------------------

#### Result

* The screen is divided into **three equal sections**
* Each child view takes **one-third of the screen**
* This happens because all children have `flex: 1`

---

### 7. Unequal Space Distribution

Now change the first view’s flex value.

-------------------code----------------------
export default function App() {
  return (
    <View style={{ backgroundColor: 'white', flex: 1 }}>
      <View style={{ backgroundColor: 'dodgerblue', flex: 2 }} />
      <View style={{ backgroundColor: 'gold', flex: 1 }} />
      <View style={{ backgroundColor: 'tomato', flex: 1 }} />
    </View>
  );
}
-------------------code----------------------

#### Explanation

* Total flex units: `2 + 1 + 1 = 4`
* Blue view gets **2 out of 4 units**
* Gold and tomato views get **1 out of 4 each**

#### Result

* Blue view takes **half of the screen**
* The other two each take **one quarter**

---

### 8. Key Takeaways

* `flex` controls how much space a view takes relative to its siblings
* Flex values are **relative**, not fixed sizes
* Parent views act as containers
* Child views divide available space based on their flex values

---

### 9. What’s Next

* More Flexbox properties will be covered next
* Including alignment, direction, and spacing


* Compare React Native flex vs CSS flexbox

Below is a **clear, structured comparison** between **React Native Flex** and **CSS Flexbox**, written as study notes with examples and no emojis.

---

# React Native Flex vs CSS Flexbox

## 1. Default Behavior

| Feature                | React Native    | CSS                   |
| ---------------------- | --------------- | --------------------- |
| Default `display`      | `flex` (always) | `block`               |
| Need to enable flexbox | No              | Yes (`display: flex`) |

### Example

**React Native**

-------------------code----------------------
<View style={{ flex: 1 }} />
-------------------code----------------------

**CSS**

-------------------code----------------------
.container {
  display: flex;
}
-------------------code----------------------

---

## 2. Default Flex Direction

| Property        | React Native | CSS   |
| --------------- | ------------ | ----- |
| `flexDirection` | `column`     | `row` |

### Example

**React Native**

-------------------code----------------------
<View style={{ flexDirection: 'column' }}>
  <View />
  <View />
</View>
-------------------code----------------------

**CSS**

-------------------code----------------------
.container {
  display: flex;
  flex-direction: row;
}
-------------------code----------------------

This difference causes the most confusion for beginners.

---

## 3. Measurement Units

| Feature     | React Native               | CSS                    |
| ----------- | -------------------------- | ---------------------- |
| Units       | Density-independent pixels | px, %, em, rem, vh, vw |
| Percentages | Limited support            | Fully supported        |

### Example

**React Native**

-------------------code----------------------
width: 100,
height: 50
-------------------code----------------------

**CSS**

-------------------code----------------------
width: 100px;
height: 50px;
-------------------code----------------------

React Native numbers are not pixels but **logical units** that scale across screen densities.

---

## 4. Flex Value Meaning

| Behavior          | React Native         | CSS            |
| ----------------- | -------------------- | -------------- |
| `flex: 1`         | Take available space | Grow factor    |
| Shorthand support | Simplified           | Full shorthand |

### Example

**React Native**

-------------------code----------------------
<View style={{ flex: 2 }} />
-------------------code----------------------

**CSS**

-------------------code----------------------
.item {
  flex: 2 1 auto;
}
-------------------code----------------------

In CSS:

* `flex-grow`
* `flex-shrink`
* `flex-basis`

In React Native:

* `flex` mainly controls growth

---

## 5. Axis Alignment

| Property         | React Native | CSS        |
| ---------------- | ------------ | ---------- |
| `justifyContent` | Main axis    | Main axis  |
| `alignItems`     | Cross axis   | Cross axis |
| `alignSelf`      | Cross axis   | Cross axis |

Behavior is mostly the same, but **axis direction differs due to default flexDirection**.

---

## 6. Gap Support

| Feature            | React Native             | CSS             |
| ------------------ | ------------------------ | --------------- |
| `gap`              | Limited / newer versions | Fully supported |
| Common alternative | Margins                  | Gap             |

### Example (RN workaround)

-------------------code----------------------
<View style={{ marginBottom: 10 }} />
-------------------code----------------------

---

## 7. Wrapping Behavior

| Feature    | React Native | CSS       |
| ---------- | ------------ | --------- |
| `flexWrap` | Supported    | Supported |
| Default    | `nowrap`     | `nowrap`  |

### Example

-------------------code----------------------
<View style={{ flexWrap: 'wrap' }} />
-------------------code----------------------

---

## 8. Positioning

| Feature    | React Native           | CSS                                       |
| ---------- | ---------------------- | ----------------------------------------- |
| `position` | `relative`, `absolute` | `static`, `relative`, `absolute`, `fixed` |
| `fixed`    | Not supported          | Supported                                 |

React Native does not support `position: fixed`.

---

## 9. Layout Engine

| Feature   | React Native | CSS                   |
| --------- | ------------ | --------------------- |
| Engine    | Yoga         | Browser layout engine |
| Rendering | Native views | DOM elements          |

React Native layout is calculated **before rendering**, not by a browser.

---

## 10. Styling Method

| Feature        | React Native       | CSS                               |
| -------------- | ------------------ | --------------------------------- |
| Style format   | JavaScript objects | CSS files                         |
| Dynamic styles | Very easy          | Requires classes or inline styles |

### Example

**React Native**

-------------------code----------------------
style={{ flex: isActive ? 1 : 0 }}
-------------------code----------------------

**CSS**

-------------------code----------------------
.active {
  flex: 1;
}
-------------------code----------------------

---

## 11. Unsupported CSS Features in React Native

React Native **does not support**:

* `float`
* `grid`
* `z-index` behavior like web
* Pseudo-classes (`:hover`, `:focus`)
* Media queries (handled differently)

---

## 12. Mental Model Difference

### CSS Flexbox

* Document-based layout
* Browser-controlled rendering
* Many legacy behaviors

### React Native Flex

* App-based layout
* Predictable and strict
* Optimized for performance

---

## 13. Summary Table

| Topic             | React Native  | CSS            |
| ----------------- | ------------- | -------------- |
| Default direction | Column        | Row            |
| Units             | Logical units | Multiple units |
| Layout engine     | Yoga          | Browser        |
| Flex shorthand    | Simplified    | Full           |
| Platform          | Mobile apps   | Web            |

---

## Final Advice

If you know CSS Flexbox:

* Forget defaults
* Think in columns first
* Always define container size
* Rely on `flex` more than fixed widths

If you want, I can:

* Draw mental diagrams for axis directions
* Convert CSS layouts to React Native
* Create flexbox exercises with answers
